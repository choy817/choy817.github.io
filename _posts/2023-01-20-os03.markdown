---
layout: post
title: "[운영체제]메모리"
category: 운영체제
---

### 메모리 계층
---

계층 위로 올라갈 수록
- 가격은 비싸지고
- 용량도 작아지고
- 속도는 빨라진다   

메모리 계층이 있는 이유는 경제성과 캐시 때문   
ex) 16GB RAM은 8만원 주고 사지만 16GB SSD는 더 싼 가격에 살 수 있음

(1) 레지스터
- CPU 안에 있는 작은 메모리
- 휘발성, 속도 가장 빠름
- 기억 용량이 가장 적다

(2) 캐시
- L1, L2 캐시를 지칭
- 휘발성, 속도 빠름
- 기억 용량이 적다

(3) 주기억장치
- RAM을 가리킨다
- 휘발성, 속도 보통
- 기억 용량 보통

(4) 보조기억장치
- HDD, SSD를 일컫는다
- 휘발성, 속도 낮음
- 기억 용량이 많다


### 캐시
---
- 데이터를 미리 복사해 놓는 임시 저장소   
- 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리   
- 속도 차이를 해결하기 위해 (A)계층과 (B)계층 사이에 있는 계층을 캐싱 계층이라고 한다.   
&nbsp;

(1) 캐시를 직접 설정하는 방법   
자주 사용하는 데이터를 기반으로 설정해야 한다. 자주 사용하는 데이터의 근거가 되는 것이 지역성이다.  

- 시간 지역성 : 최근 사용한 데이터에 다시 접근하려는 특성   
- 공간 지역성 : 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성   
&nbsp;

(2) 웹 브라우저의 캐시   
- 사용자의 커스텀한 정보나 인증 모듈 관련사항을 브라우저에 저장   
- 추후 서버에 요청할 때 자신을 나타내는 아이덴티티나 중복 요청 방지를 위해 쓰인다.    
&nbsp;

\- 쿠키
- 만료기한이 있는 키-값 저장소
- 서버에서 만료기한을 정한다.(클라이언트에서도 가능)   

\- 로컬 스토리지
- 만료기한이 없는 키-값 저장소  
- 웹 브라우저를 닫아도 유지
- 도메인 단위로 저장, 생성됨
- HTML5를 지원하지 않는 웹브라우저에서는 사용이 불가
- 클라이언트만 수정 가능

\- 세션 스토리지   
- 만료기한이 없는 키-값 저장소
- 탭 단위로 세션 스토리지를 생성
- 탭을 닫으면 데이터가 삭제된다
- HTML5를 지원하지 않는 웹브라우저에서는 사용이 불가
- 클라이언트만 수정 가능
&nbsp;


### 메모리 관리
---
컴퓨터 내의 한정된 메모리를 극한으로 활용해야 하는것이 운영체제의 대표적인 할 일 중 하나이다.   

(1) 가상 메모리   
- 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 사용자들에게 매우 큰 메모리로 보이게 만드는 것   
- 가상적으로 주어진 주소를 가상 주소, 실제 메모리상에 있는 주소를 실제 주소라고 한다.
- 가상 주소는 메모리관리장치에 의해 실주소로 변환, 사용자는 실주소 의식 필요 없이 프로그램을 구축 가능
&nbsp;

(2) 스와핑    
- 가상메모리에는 존재하지만 실메모리인 RAM에는 없는 데이터일 경우 페이지 폴트가 발생함
- 이를 방지하기 위해 당장 사용하지 않는 영역을 하드디스크로 옮겼다가, 필요할 때 RAM으로 불러와 올린다
- 페이지 폴트 발생 시 스와핑하는 과정
  - CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생시켜 운영체제에 알림
  - 운영체제는 CPU의 동작을 잠시 멈춤
  - 운영체제는 페이지 테이블을 확인, 없으면 프로세스를 중단하고 물리 메모리에 비어있는 프레임이 있는지 탐색
  - 비어 있는 프레임이 없다면 스와핑 발동
  - 비어 있는 프레임에 페이지를 로드 후 페이지 테이블 최신화
  - CPU 다시 시작
&nbsp;   

(3) 스래싱
- 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나서 발생한다
- 페이지 폴트가 일어나면 CPU 이용률이 낮아지고, 운영체제는 CPU가 놀고 있는 것으로 착각해 더 많은 프로세스를 메모리에 올린다.
- 운영체제에서 스래싱을 해결할 수 있는 방법
  - 워킹 셋 : 지역성을 통해 결정된 페이지 집합을 만들어 미리 메모리에 로드하는 것
  - PFF : 상한선과 하한선을 만들어 상한선에 도달하면 페이지를 늘리거, 하한선에 도달하면 페이지를 줄인다
- 기타적으로 메모리를 늘리거나, HDD를 SSD로 바꾸는 등의 해결 방법이 있음
&nbsp;

### 메모리 할당
---
(1) 연속 할당   
메모리에 연속적으로 공간을 할당하는 것   
- 고정 분할 방식   
  - 메모리를 미리 나누어 관리하는 방식.
  - 융통성이 없고 내부 단편화가 발생한다.   
  
- 가변 분할 방식   
  - 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용한다.
  - 외부 단편화가 발생할 수 있음   

|구분   |내용 |
|---|---|
|최초 적합   |위쪽이나 아래쪽부터 시작해서 메모리 공간을 찾으면 바로 할당 |
|최적 적합   |프로세스 크기 이상인 공간 중 가장 작은 메모리부터 할당|
|최악 적합   |프로세스 크기와 가장 차이가 많이 나는 메모리에 할당|   



(2) 불연속 할당   
- 페이징   
  - 동일한 크기의 페이지 단위로 나누어 할당
  - 주소 변환이 복잡해짐
  
- 세그멘테이션   
  - 페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 것
  - 공유과 보안 측면에서 좋음
  
- 페이지드 세그멘테이션    
  - 공유나 보안을 세그먼트로 나누고, 물리적 메모리는 페이지로 나눔
&nbsp;

### 페이지 교체 알고리즘     
--- 
메모리는 한정되어 있기 때문에 페이지 교체 알고리즘을 기반으로 스와핑이 많이 일어난다. 스와핑은 많이 일어나지 않도록 설계되어야 한다.   
&nbsp;  
(1) 오프라인 알고리즘   
- 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘
- 미래에 사용되는 프로세스를 알수 없기 때문에 사용하지 않음
- 다른 알고리즘과의 성능 비교를 위한 기준을 제공
  
(2) FIFO   
- First In First Out
- 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법
  
(3) LRU   
- Least Recentle Used
- 참조가 가장 오래된 페이지를 바꿈
- 오래된 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 한다
  
(4) NUR   
- Not Used Recently
- LRU에서 발전한 알고리즘
- clock 알고리즘이라고 하며 0과 1을 가진 비트를 둔다.
  - 1 : 최근에 참조되었음
  - 0 : 참조되지 않았음
- 시계방향으로 돌며 0을 찾으며, 찾은 경우 프로세스를 교체하고 비트를 1로 바꾼다
  
(5) LFU
- Least Frequently Used
- 가장 참조 횟수가 적은 페이지를 교체한다
