---
layout: post
title: "[DB]데이터베이스의 종류와 인덱스"
category: DB
---

### 데이터베이스의 종류
---
#### 관계형 데이터베이스
- 행과 열을 가지는 표 형식 데이터를 저장하는 데이터베이스
- SQL을 써서 조작한다
- mySQL, Oracle, MSSQL...
- 표준 SQL을 지키기는 하나 각각의 제품에 특화된 SQL을 사용한다


#### NoSQL 데이터베이스
- Not Only SQL
- SQL을 사용하지 않는 데이터베이스
- MongoDB, redis...

&nbsp;


### 인덱스
---
- 데이터를 빠르게 찾을 수 있는 장치(책에 있는 찾아보기)
- 인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형잡힌 트리 구조와 트리 깊이의 대수확장성 때문이다
  - 대수확장성 : 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것   

&nbsp;

#### 인덱스를 만드는 방법

🔘 관계형(MySQL)
- 클러스터형 인덱스 : 테이블 당 하나를 설정할 수 있다
    - primary key를 옵션으로 기본키를 만들면 생성할 수 있다
    - 기본키로 만들지 않고 unique not null 옵션을 붙여도 생성이 가능하다
 
- 세컨더리 인덱스 : 보조 인덱스. 여러 개의 필드값을 기반으로 쿼리를 많이 보낼 때 생성
  - create index...기반으로 인덱스를 만들 수 있다


하나의 인덱스만 생성할 것이면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스보다 성능이 좋다


🔘 NoSQL(MongoDB)
- 도큐먼트를 만들면 자동으로 ObjectID가 형성, 기본키로 설정된다
- 세컨더리 키도 부가적으로 설정해서 기본키와 세컨더리 키를 같이 쓰는 복합 인덱스를 설정할 수 있다


&nbsp;

#### 인덱스 최적화 기법

🔘 인덱스는 비용이다   
- 두번 탐색하도록 강요
  - 인덱스 리스트, 그다음 컬렉션 순으로 탐색하기 때문이며 관련 읽기 비용이 듦
- 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다
  
🔘 항상 테스팅하라   
- 인덱스 최적화 기법은 서비스 특징에 따라 달라지기 때문에 항상 테스팅하는 것이 중요하다
  
🔘 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
- 인덱스를 생성할 때는 순서가 있고 이 순서에 따라 성능이 달라진다
  - 어떠한 값과 같음을 비교하는 ==이나 equal이라는 쿼리가 있으면 제일 먼저 인덱스로 설정한다
  - 정렬에 쓰는 필드라면 그 다음 인덱스로 설정한다
  - 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >이거나 <등 많은 값을 출력하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정한다
  - 유니크한 값의 정도를 카디널리티라고 한다. 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 한다
    - ex. age와 email이 있을 경우 email이 카디널리티가 높기 때문에 email필드에 대한 인덱스를 먼저 생성한다





